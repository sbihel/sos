\documentclass{article}

\usepackage{dsfont}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{semantic}
\usepackage{xcolor}
\usepackage{listings}
\lstset{
basicstyle=\ttfamily,
frame=single,
numbers=left
}
\usepackage{fullpage}
\usepackage{mathpartir}

\newcommand{\todo}[1]{\textcolor{red}{\textbf{ToDo}\ifx&#1&\else ~[\emph{#1} ]~\fi}}
\newcommand{\fixme}[1]{\textcolor{purple}{\textbf{FixMe}\ifx&#1&\else ~[ \emph{#1} ]~\fi}}
\newcommand{\note}[1]{\textcolor{blue}{\textbf{Note}\ifx&#1&\else ~[ \emph{#1} ]~\fi}}

\title{SOS --- Homework}

\author{Simon Bihel \and Lesly-Ann Daniel}

\date{M2 SIF, 2017--2018}

\begin{document}
\maketitle

\section*{Question 1 - v1}
%------------------------ Part 1
Let \(\mathcal{N}\) be the interpretation function for constants:
\[ \mathcal{N} = Num \rightarrow \mathbb{Z} \]
In our extended \texttt{While} language, values are either integers or arrays, thus we define the set of program values:
\[ \textbf{Val} = \mathbb{Z} \cup \textbf{Arr}\]
We define the set of arrays as the set of all functions from indexes (natural numbers) to program values, plus the value \(nil\) for undefined arrays: \note{We could define the set of array as the set of finite sequences of values, it might be more readable/easier to understand...}
\[\textbf{Arr} = \{x:\mathbb{N} \rightarrow \textbf{Val}\} \cup \{nil\} \]
Finally, a state is represented by a function from program variables to values:
\[\sigma \in \textbf{State} = \textbf{Var} \rightarrow \textbf{Val} \]

%------------------------ Part 2
Arithmetic expressions are extended from integers to integers or arrays.
The denotational semantic of arithmetic expressions is defined by the following rules:
\begin{center}
\begin{tabular}{ l c l }
\multicolumn{3}{l}{\(\mathcal{A}: \textbf{Aexp} \rightarrow \textbf{State} \rightarrow \textbf{Val}\)} \\
 \(\mathcal{A}\llbracket n \rrbracket \sigma \) & \(=\) & \(\mathcal{N}\llbracket n \rrbracket\)\\ 
 \(\mathcal{A}\llbracket x \rrbracket \sigma \) & \(=\) & \(\sigma x\)\\  
 \(\mathcal{A}\llbracket a_1 \circ a_2 \rrbracket \sigma \) & \(=\) &
    if \(\mathcal{A}\llbracket a_1\rrbracket \sigma \in \mathbb{Z}\) and \(\mathcal{A}\llbracket a_2\rrbracket \sigma \in \mathbb{Z}\)\\
    & & then \(\mathcal{A}\llbracket a_1\rrbracket \sigma \circ \mathcal{A}\llbracket a_2\rrbracket \sigma\)\\ 
 \(\mathcal{A}\llbracket x.length \rrbracket \sigma \) & \(=\) & if \(\sigma x \in \{\textbf{Arr} \setminus {nil}\}\) then \(|dom(\sigma x)|\) \\ 
 \(\mathcal{A}\llbracket x[a] \rrbracket \sigma \) & \(=\) &
    if \(\sigma x \in \{\textbf{Arr} \setminus {nil}\}\) and \(\mathcal{A}\llbracket a\rrbracket \sigma \in dom(\sigma x)\)\\
    & & then \(\sigma x (\mathcal{A}\llbracket a\rrbracket \sigma)\)
\end{tabular}
\end{center}
Note the following changes from the definition of the while language:
\begin{itemize}
\item \(\mathcal{A}\llbracket x \rrbracket \sigma \) can now return an integer or an array.
\item \(\mathcal{A}\llbracket a_1 \circ a_2 \rrbracket \sigma \) is not defined if \(a_1\) and \(a_2\) are not integers.
\item \(\mathcal{A}\llbracket x.length \rrbracket \sigma \) is not defined if \(x\) is an integer or the \(null\) array.
\item \(\mathcal{A}\llbracket x.length \rrbracket \sigma \) is the cardinal of the domain of \(\sigma x\) otherwise, i.e. the number of indexes upon which the array \(x\) is defined.
\item \(\mathcal{A}\llbracket x[a] \rrbracket \sigma \) is not defined if \(x\) is an integer or the \(null\) array. Moreover, it is only defined if the index \(a\) is in the domain of \(\sigma x\) i.e. if \(a\) is a valid index of \(x\).
\item If \(\mathcal{A}\llbracket x[a] \rrbracket \sigma \) is defined, it first applies \(x\) to \(\sigma\) which returns the array, represented as a function. Then it does the dereferencing by applying \(\mathcal{A}\llbracket a \rrbracket \sigma\) to the array function, and returns an integer or an array.
\end{itemize}

The denotational semantic of boolean expressions is defined by the following rules:
\begin{center}
\begin{tabular}{ l c l }
\multicolumn{3}{l}{\(\mathcal{B}: \textbf{Bexp} \rightarrow \textbf{State} \rightarrow \mathbb{B}\)} \\
 \(\mathcal{B}\llbracket true \rrbracket \sigma \) & \(=\) & \(\textbf{tt}\)\\ 
 \(\mathcal{B}\llbracket false \rrbracket \sigma \) & \(=\) & \(\textbf{ff}\)\\  
 \(\mathcal{B}\llbracket a_1 \circ a_2 \rrbracket \sigma \) & \(=\) &
    if \(\mathcal{A}\llbracket a_1\rrbracket \sigma \in \mathbb{Z}\) and \(\mathcal{A}\llbracket a_2\rrbracket \sigma \in \mathbb{Z}\)\\
    & & then \(\mathcal{A}\llbracket a_1\rrbracket \sigma \circ \mathcal{A}\llbracket a_2\rrbracket \sigma\)\\ 
 \(\mathcal{B}\llbracket \text{not } b \rrbracket \sigma \) & \(=\) & \(\neg(\mathcal{B}\llbracket b \rrbracket \sigma)\) \\
 \(\mathcal{B}\llbracket b_1 \text{ and } b_2 \rrbracket \sigma \) & \(=\) &
    \((\mathcal{B}\llbracket b_1 \rrbracket \sigma) \wedge (\mathcal{B}\llbracket b_2 \rrbracket \sigma)\) \\
 \(\mathcal{B}\llbracket b_1 \text{ or } b_2 \rrbracket \sigma \) & \(=\) &
    \((\mathcal{B}\llbracket b_1 \rrbracket \sigma) \vee (\mathcal{B}\llbracket b_2 \rrbracket \sigma)\) \\
\end{tabular}
\end{center}
Note that  \(\mathcal{B}\llbracket a_1 \circ a_2 \rrbracket \sigma \) is not defined if \(a_1\) and \(a_2\) are not integers.
Consequently, some rules parameterized by booleans expressions in the small-step semantic might be blocking on undefined booleans expressions.

The structural operational semantics (small-step) comprises all the previous rules plus the following extension:
\begin{mathpar}
\inference[ARR\_DECL\_I]{}{(x := \text{new array[int]}(a), \sigma) \rightarrow
\sigma[x \mapsto x(i) = 0, \forall i \in [0 .. (a-1)] ]}
\and
\inference[ARR\_DECL\_A]{}{(x := \text{new array[} \text{\textit{arr\_dcl}]}(a), \sigma) \rightarrow
\sigma[x \mapsto x(i) = nil, \forall i \in [0 .. (a-1)] ]}
\and
\inference[ARR\_UPDATE]{}
    {(x[a_1] := a_2, \sigma) \rightarrow
     \sigma[x \mapsto \sigma x[\mathcal{A}\llbracket a_1 \rrbracket \sigma \mapsto \mathcal{A}\llbracket a_2 \rrbracket \sigma]]}
     [if \(\mathcal{A}\llbracket a_1\rrbracket \sigma \in dom(\sigma x)\)]
\end{mathpar}
The array declaration is split into two rules:
\begin{itemize}
 \item \textsc{Arr\_Decl\_I} is the declaration of arrays of integers. The arrays \(x\) is initialized as a function mapping indexes (from 0 to \(a-1\)), to 0.
 \item \textsc{Arr\_Decl\_A} is the declaration of arrays of arrays. The arrays \(x\) is initialized as a function mapping indexes (from 0 to \(a-1\)), to \(nil\).
\end{itemize}
The \textsc{Arr\_Update} is conditioned by the fact that the index \(a_1\) is in the bound of the array. \textsc{Arr\_Update} consists in updating the function \(\sigma x\) by mapping the index \(a_1\) to its new value \(a_2\), and then updating the store \(\sigma\) with the new value of \(\sigma x\).


\section*{Question 2}
The definition of the big-step semantic would not change, except for the addition of the above rules that would be straightforward.
Indeed, the rules defined above do not manipulate commands, so their translation into big-step semantic only consists in changing the transition relation from small-step to big-step.

There would be more blocking configurations because some rules of the big step-semantic are parameterized by a boolean evaluation which can be undefined (to avoid the comparison of arrays) in our extended semantic contrary to the original semantic.

\section*{Question 3}
% Question 3. We suppose that all instructions are given a unique label. Propose a data-flow analysis for
% determining the potential may-aliases at each program point. You may want to use the allocation site of
% an array as abstraction but other abstract domains for modeling memory allocation are also welcome. The
% allocation site of an array is the label of the new instruction that created it.

We enrich the syntax of the \texttt{While} language with labels:
\begin{equation*} \label{eq1}
\begin{split}
S::= & [x := a]^l
     \ |\ [\text{skip}]^l
     \ |\ S_1;S_2
     \ |\ \text{if } [b]^l \text{ then } S_1 \text{ else } S_2 
     \ |\ \text{while } [b]^l \text{ do } S \ |\\
     & [x := \text{new } arr\_decl(a)]^l
     \ |\ [x[a_1] := a_2]^l\\
& n \in \textbf{Num}, x \in \textbf{Var}, a \in \textbf{Aexp}, b \in \textbf{Bexp}, S \in \textbf{Comm}, l \in \textbf{Lab}
\end{split}
\end{equation*}

For each instruction \(S \in \textbf{Comm}\), we associate:
\begin{center}
\begin{tabular}{ l l l }
\(init(S)\) & \(\in \textbf{Lab}\) &  \textit{the entry point label of S}\\
\(final(S)\) & \(\subseteq \textbf{Lab}\) &  \textit{the exit point labels of S}\\
\(labels(S)\) & \(\subseteq \textbf{Lab}\) &  \textit{the labels which appear in S}\\
\(flow(S)\) & \(\subseteq \textbf{Lab} \times \textbf{Lab}\) &  \textit{the edged of the control flow graph}
\end{tabular}
\end{center}
which are defined as follow:
\begin{center}
\begin{tabular}{ l l }
\( init([x := a]^l) \)                                           & \( = l\)\\
\( init([\text{skip}]^l) \)                                      & \( = l\)\\
\( init(S_1;S_2) \)                                              & \( = init(S_1)\)\\
\( init(\text{if } [b]^l \text{ then } S_1 \text{ else } S_2) \) & \( = l\)\\
\( init(\text{while } [b]^l \text{ do } S) \)                    & \( = l\)\\
\( init([x := \text{new } arr\_decl(a)]^l) \)                    & \( = l\)\\
\( init([x[a_1] := a_2]^l) \)                                    & \( = l\)
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{ l l }
\( final([x := a]^l) \)                                           & \( = \{l\}\)\\
\( final([\text{skip}]^l) \)                                      & \( = \{l\}\)\\
\( final(S_1;S_2) \)                                              & \( = final(S_2)\)\\
\( final(\text{if } [b]^l \text{ then } S_1 \text{ else } S_2) \) & \( = final(S_1) \cup final(S_2)\)\\
\( final(\text{while } [b]^l \text{ do } S) \)                    & \( = \{l\}\)\\
\( final([x := \text{new } arr\_decl(a)]^l) \)                    & \( = \{l\}\)\\
\( final([x[a_1] := a_2]^l) \)                                    & \( = \{l\}\)
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{ l l }
\( labels([x := a]^l) \)                                           & \( = \{l\}\)\\
\( labels([\text{skip}]^l) \)                                      & \( = \{l\}\)\\
\( labels(S_1;S_2) \)                                              & \( = labels(S_1) \cup labels(S_2)\)\\
\( labels(\text{if } [b]^l \text{ then } S_1 \text{ else } S_2) \) & \( = \{l\} \cup labels(S_1) \cup labels(S_2)\)\\
\( labels(\text{while } [b]^l \text{ do } S) \)                    & \( = \{l\} \cup labels(S)\)\\
\( labels([x := \text{new } arr\_decl(a)]^l) \)                    & \( = \{l\}\)\\
\( labels([x[a_1] := a_2]^l) \)                                    & \( = \{l\}\)
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{ l l }
\( flow([x := a]^l) \)                                           & \( = \emptyset \)\\
\( flow([\text{skip}]^l) \)                                      & \( = \emptyset \)\\
\( flow(S_1;S_2) \)                                              &
    \( = flow(S_1) \cup flow(S_2) \cup \{(l,init(S_2))\ |\ l \in final(S_1)\}\)\\
\( flow(\text{if } [b]^l \text{ then } S_1 \text{ else } S_2) \) &
    \( = flow(S_1) \cup flow(S_2) \cup \{(l,init(S_1))\} \cup \{(l,init(S_2))\}\)\\
\( flow(\text{while } [b]^l \text{ do } S) \)                    &
    \( = flow(S) \cup \{(l',l)\ |\ l' \in final(S)\} \cup \{(l,init(S))\}\)\\
\( flow([x := \text{new } arr\_decl(a)]^l) \)                    & \( = \emptyset \)\\
\( flow([x[a_1] := a_2]^l) \)                                    & \( = \emptyset \)\\
\end{tabular}
\end{center}

An allocation is represented by a couple \((v,l) \in \textbf{Var} \times \textbf{Lab}^\textbf{?}\)
with \(\textbf{Lab}^\textbf{?} = \textbf{Lab} \cup \{?\}\).
\begin{itemize}
 \item \((v,l)\) : The array \(v\) has been allocated a program point \(l\).
 \item (v,?) : The array \(v\) is not allocated.
\end{itemize}
At each label l, we compute the two sets:
\begin{itemize}
 \item \(M\!A_\text{in}(l)\), the allocated arrays that enter in \(l\)
 \item \(M\!A_\text{out}(l)\), the allocated arrays that exit from \(l\)
\end{itemize}

The ``gen-kill'' rules for the MA analysis are the following:
\begin{center}
\begin{tabular}{ l l l l}
\( kill([x := a]^l) \)      & = & \( \{(x,l')\ |\ l' \in \textbf{Lab}^?\} \) & \textit{kill any previous alloc. of x}\\ 
\( kill([\text{skip}]^l) \) & = & \( \emptyset \) \\
\( kill([b]^l) \)           & = & \( \emptyset \) \\
\( kill([x := \text{new } arr\_decl(a)]^l) \) & = & \( \{(x,l')\ |\ l' \in \textbf{Lab}^?\} \) & \textit{kill any previous alloc. of x}\\ 
\( kill([x[a_1] := a_2]^l) \) & = & \(\emptyset\)
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{ l l l }
\( gen([x_1 := x_2]^l) \)    & =  \( (x_1,l')\ |\ (x_2,l') \in  M\!A_\text{in}(l) \)
                             & \textit{add any allocation reachable via \(x_2\) }\\
\( gen([x_1 := x_2[a]]^l) \) & =  \( (x_1,l')\ |\ (x_2,l') \in  M\!A_\text{in}(l) \)
                             & \textit{add any allocation reachable via \(x_2\) }\\ 
\( gen([x := a]^l) \)        & =  \( \emptyset \)
                             & \textit{if \(a_2\) is not a variable}\\ 
\( gen([\text{skip}]^l) \)   & =  \( \emptyset \) \\
\( gen([b]^l) \)             & =  \( \emptyset \) \\

\( gen([x := \text{new } arr\_decl(a)]^l) \) & =  \( \{(x,l)\} \) & \textit{create new alloc. for x}\\

\( gen([x_1[a] := x_2]^l) \)        & =  \( (x_1,l')\ |\ (x_2,l') \in  M\!A_\text{in}(l) \)
                                    & \textit{add any allocation reachable via \(x_2\) }\\
\( gen([x_1[a_1] := x_2[a_2]]^l) \) & =  \( (x_1,l')\ |\ (x_2,l') \in  M\!A_\text{in}(l) \)
                                    & \textit{add any allocation reachable via \(x_2\) }\\ 
\( gen([x[a_1] := a_2]^l) \)        & =  \( \emptyset \)
                                    & \textit{if \(a_2\) is not a variable}\\
\end{tabular}
\end{center}

For all program point \([i]^l \in P\), we compute the sets \(M\!A_\text{in}(l)\) and \(M\!A_\text{out}(l)\):
 \[
    M\!A_\text{in}(l) =
    \begin{cases}
      \{(x,?)\ |\ x \in \textbf{Var}\},                        & \text{if } l=init(P)\\
      \bigcup\limits_{(l,l') \in flow(P)} M\!A_\text{out}(l'), & \text{otherwise}
    \end{cases}
\]
\[
    M\!A_\text{out}(l) = M\!A_\text{in}(l) \setminus kill([i]^l) \cup gen([i]^l)
\]

\section*{Question 4}
Imprecisions:

Conditional statements, because unreachable 
\begin{lstlisting}
if(x < 0)
  x = new array[int](10)
if(x > 0)
  y = x // Triggers a may alias but actually there is none.
\end{lstlisting}

We do not differentiate allocations reachable via \(x\) and allocations reachable via \(x[i]\), in both case, we add the allocation as \((x,l)\).
Moreover in case of an assignment \([x_1 := x_2[a]]^l\) where \(x_2\) is an array of integers, we add its reachable expressions to \(x_1\) although it is not necessary.
This constitutes an over-approximation in the analysis.

Updating an array with a reference: \( kill([x[a_1] := a_2]^l) \)  might override an allocation labeled l, which is no longer reachable via x, but we cannot know so we keep (x,l) in the list.

Improvements:


\section*{Question 5}
\paragraph{Definition of types}
The definition of types we consider in our program are booleans, integers and multidimensional arrays of integers. We define a particular type for the commands. Therefore, we define the types \(T\) as:
\begin{equation*} \label{eq1}
\begin{split}
T' & ::= \text{Nat}\ |\ \text{Array}[T']\\
T  & ::= \text{Bool}\ |\ \text{Cmd}\ |\ T'
\end{split}
\end{equation*}

\paragraph{Guarantees}
\todo{What we guarantee:}


What we do not guarantee:
We cannot guarantee a non blocking execution if the program is well typed because we chose to initialize arrays of arrays to \(nil\).
It is not possible to guarantee that a reference is not \(nil\) with a type system. This would require a static dataflow analysis.
Therefore we cannot guarantee that the program does not try to dereference a \(nil\) reference, we only check this at runtime in the Aexp evaluation and then block the execution.

Even if we choose to initialize arrays of arrays directly (\texttt{new array[array[int]](10)} would then return an \(10 \times 10\) array), and to not consider \(nil\) references, we would not have the guarantee that the program is non blocking because we cannot guarantee the absence of  array overflows or underflows. This guarantee would also require a dataflow analysis.

\paragraph{Typing Rules}
We define the type judgment \(\Gamma \vdash S\) meaning that the command \(S\) is well-typed in the context \(\Gamma\) with the following typing rules:

First we define the typing rules for values:
\begin{mathpar}
\textsc{T-Nat} \quad \Gamma \vdash n : \text{Nat}
\and
\textsc{T-True} \quad \Gamma \vdash true : \text{Bool}
\and
\textsc{T-False} \quad \Gamma \vdash false : \text{Bool} 
\end{mathpar}

Then, the typing rules for arithmetic expressions:
\begin{mathpar}
\inference[\textsc{T-Var}]
    {x : t \in \Gamma}
    {\Gamma \vdash x : t}{}
\and
\inference[\textsc{T-Aop}]
    {\Gamma \vdash a_1 : \text{Nat} \quad \Gamma \vdash a_2 : \text{Nat}}
    {\Gamma \vdash a_1 \circ a_2 : \text{Nat}}{(\circ \in \{+, -,\times\})}
\and
\inference[\textsc{T-Len}]
    {x : \text{Array}[t] \in \Gamma}
    {\Gamma \vdash x.length : \text{Nat}}{}
\and
\inference[\textsc{T-Deref}]
    {x : \text{Array}[t] \in \Gamma \quad \Gamma \vdash a : \text{Nat}}
    {\Gamma \vdash  x[a] : t}{}
\end{mathpar}

Then the typing rules for boolean expressions:

\begin{mathpar}
\inference[\textsc{T-Comp}]
    {\Gamma \vdash a_1 : \text{Nat} \quad \Gamma \vdash a_2 : \text{Nat}}
    {\Gamma \vdash a_1 \circ a_2 : \text{Bool}}{(\circ \in \{=, \leq\})}
\and
\inference[\textsc{T-Not}]
    {\Gamma \vdash b : \text{Bool}}
    {\Gamma \vdash \texttt{not } b : \text{Bool}}{}
\and
\inference[\textsc{T-Or}]
    {\Gamma \vdash b_1 : \text{Bool} \quad \Gamma \vdash b_2 : \text{Bool}}
    {\Gamma \vdash  b_1 \texttt{ or } b_2 : \text{Bool}}{}
\and
\inference[\textsc{T-And}]
    {\Gamma \vdash b_1 : \text{Bool} \quad \Gamma \vdash b_2 : \text{Bool}}
    {\Gamma \vdash  b_1 \texttt{ and } b_2 : \text{Bool}}{}
\end{mathpar}

Finally, we define the typing rules for commands:
\begin{mathpar}
\inference[\textsc{T-Assign}]
    {x : t \in \Gamma \quad \Gamma \vdash a : t}
    {\Gamma \vdash  x := a : \text{Cmd}}{}
\and
\inference[\textsc{T-Skip}]
    {}
    {\Gamma \vdash \texttt{skip} : \text{Cmd}}{}
\and
\inference[\textsc{T-Seq}]
    {\Gamma \vdash S_1 : \text{Cmd} \quad \Gamma \vdash S_2 : \text{Cmd}}
    {\Gamma \vdash S_1; S_2 : \text{Cmd}}{}
\and
\inference[\textsc{T-If}]
    {\Gamma \vdash b : Bool \quad \Gamma \vdash S_1 : \text{Cmd} \quad \Gamma \vdash S_2 : \text{Cmd}}
    {\Gamma \vdash \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2 : \text{Cmd}}{}
\and
\inference[\textsc{T-While}]
    {\Gamma \vdash b : Bool \quad \Gamma \vdash S : \text{Cmd}}
    {\Gamma \vdash \texttt{while } b \texttt{ do } S : \text{Cmd}}{}
% \and
% \inference[\textsc{T-ADecl-Int}]
%     {x : \text{Array}[int] \in \Gamma \quad \Gamma \vdash a : \text{Nat}}
%     {\Gamma \vdash x := \texttt{new array[int]}(a) : \text{Cmd}}{}
\and
\inference[\textsc{T-ADecl-Int}]
    {}
    {\Gamma \vdash\texttt{array[int]} : \text{\text{Array}}[\text{Nat}]}{}
\and
\inference[\textsc{T-ADecl-Arr}]
    {\Gamma \vdash array\_decl : t}
    {\Gamma \vdash \texttt{array}[array\_decl] : \text{\text{Array}}[t]}{}
\and
\inference[\textsc{T-ADecl}]
    {x : t \in \Gamma \quad \Gamma \vdash arr\_decl : t \quad \Gamma \vdash a : \text{Nat}}
    {\Gamma \vdash x := \texttt{new }arr\_decl(a) : \text{Cmd}}{}
\and
\inference[\textsc{T-AUpdate}]
    {x : \text{Array}[t] \in \Gamma \quad \Gamma \vdash a_1 : \text{Nat} \quad \Gamma \vdash a_2 : t}
    {\Gamma \vdash x[a_1] := a_2 : \text{Cmd}}{}
\end{mathpar}
\end{document}
